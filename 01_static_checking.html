<html>
  <head>
    <meta charset="utf-8" />
    <title>Τύποι δεδομένων (data types)</title>
    <!-- http://web.mit.edu/6.005/www/fa15/classes/01-static-checking/ -->
    <link href="main.css" rel="stylesheet" type="text/css" />
  </head>
  <body>
    <h1>Τύποι δεδομένων</h1>
    <section>
      <p>Ο τύπος δεδομένων ορίζεται ως ένα σύνολο τιμών και ένα σύνολο πράξεων και που το αποτέλεσμα ανήκει στο σύνολο τιμών.</p>
      <p>Η Java έχει πρωταρχικούς τύπους (primitive types) τιμών όπως:</p>
      <ul>
        <li>int (ακέραιες τιμές όπως 5 και -200, μέχρι ± 2^31, ή περίπου ± 2 billion)</li>
        <li>long (για ακέραιες τιμές μέχρι ± 2^63)</li>
        <li>boolean (για true ή false)</li>
        <li>double (για δεκαδικές τιμές)</li>
        <li>char (για χαρακτήρες όπως 'A' και '$')</li>
      </ul>
      <p>Η Java έχει επίσης τύπους δεδομένων σε μορφή αντικειμένου όπως:</p>
      <ul>
        <li>String εκφράζει μια συμβολοσειρά.</li>
        <li>BigInteger εκφράζει έναν ακέραιο για μεγάλες τιμές.</li>
      </ul>
      <p>Στη Java οι πρωταρχικοί τύποι γράφονται με πεζά γράμματα ενώ τα αντικείμενα-τύποι με κεφαλαίο το πρώτο (όπως οι κλάσεις).</p>
    </section>
    <h2>Στατικός έλεγχος, δυναμικός έλεγχος και μη έλεγχος</h2>
    <section>
      <p>Υπάρχουν γλώσσες στατικού ελέγχου και δυναμικού ελέγχου.</p>
      <p>Σε αυτές του στατικού (java) γίνεται έλεγχος πριν τη μεταγλώττιση ενώ στις δυναμικού κατά την εκτέλεση (run time) όπως η python.</p>
      <p>Στον στατικό έλεγχο πιάνονται (catch):</p>
      <ul>
        <li>Λάθος σύνταξη</li>
        <li>Λάθος όνομα (reserved words)</li>
        <li>Λάθος αριθμός ορισμάτων σε συνάρτηση</li>
        <li>Λάθος τύπος ορισμάτων</li>
        <li>Λάθος τύπος επιστροφής (return)</li>
      </ul>
      <p>Στον δυναμικό έλεγχο πιάνονται (catch):</p>
      <ul>
        <li>Λάθος τιμές ορισμάτων (x/y όπου y=0)</li>
        <li>Λάθος τιμές επιστροφής</li>
        <li>Τιμές εκτός ορίων (int, πίνακες)</li>
        <li>Κλήση ή αναφορά σε αντικείμενα με τιμή null</li>
      </ul>
      <p>Γενικά στον στατικό έλεγχο το λάθος έχει σχέση με τον τύπο του ορίσματος ενώ στον δυναμικό με την τιμή του ορίσματος.</p>
      <p>Στον μη έλεγχο δεν πιάνεται κανένα λάθος.</p>
    </section>
    
    <h3>Κακές πρακτικές</h3>
    <section>
      <ul>
        <li>Μακρύς κώδικας χωρίς έλεγχο</li>
        <li>Μη καταγραφή λεπτομερειών, σημειώσεων, παρατηρήσεων κ.λπ.</li>
        <li>Να υποθέτουμε ότι δεν υπάρχουν λάθη</li>
      </ul>
  </section>
    <h3>Καλές πρακτικές</h3>
    <section>
      <ul>
        <li>Γράψτε λίγο κώδικα και ελέγξτε</li>
        <li>Τεκμηριώστε τις προυποθέσεις για σωστή λειτουργία</li>
        <li>Στατικός έλεγχος παντού</li>
      </ul>
    </section>

    <h2>Ο στόχος</h2>
    <section>
      <p>Ο κύριος στόχος είναι να παράξουμε "καλό" λογισμικό.</p>
      <ul>
        <li>Σωστό, χωρίς λάθη</li>
        <li>Κατανοητό</li>
        <li>Εύκολο σε αλλαγές και ενημέρωση</li>
      </ul>

      <p>Εκτός των παραπάνω υπάρχουν και άλλα κριτήρια αλλά αυτά είναι τα πιο βασικά για έναν προγραμματιστή.</p>
    </section>
    <h5>Ασκήσεις</h5>
    <section>
    <p>Ελέγξτε για δυναμικά, στατικά ή μη ελεγχόμενα λάθη στα παρακάτω παραδείγματα.</p>


<pre>
<span class="res">int</span> n = 5;
if (n) { //static
    n = n + 1;
}
</pre>

<pre>
<span class="res">int</span> big = 200000; // 200,000
big = big * big;  // δίνει 4 δισ.
System.out.println(big); //1345294336
</pre>

<pre>
double probability = 1/5;
System.out.println(probability); //0.0
</pre>

<pre>
<span class="res">int</span> sum = 0;
<span class="res">int</span> n = 0;
<span class="res">int</span> average = sum/n;
System.out.println(average); //ArithmeticException
</pre>

<pre>
double sum = 7;
double n = 0;
double average = sum/n;
System.out.println(average); //Infinity
</pre>

<pre>
final <span class="res">int</span> n = 5;
System.out.println(n++);
</pre>    
</section>

    <h5>To Hailstone σε μια κλάση</h5>
<section>
<pre>
public class Hailstone {
  /**
  * Compute a hailstone sequence.
  * @param n  Starting number for sequence.  Assumes n > 0.
  * @return hailstone sequence starting with n and ending with 1.
  */
  public static List<Integer> hailstoneSequence(<span class="res">int</span> n) {
    List<Integer> list = new ArrayList<Integer>();
    while (n != 1) {
      list.add(n);
      if (n % 2 == 0) {
        n = n / 2;
      } else {
        n = 3 * n + 1;
      }
    }
    list.add(n);
    return list;
  }
}
</pre>
</section>
  </body>
</html>




